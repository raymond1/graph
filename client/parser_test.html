<html>
<head>
<title>Test</title>
<meta charset="utf-8" /> 
<style>
.expandable{
  color: #4a8;
}
</style>
</head>
<body>
  <div id="test">

  </div>
<script src='programming.js'></script>
<script src='strings.js'></script>
<script src='parser.js'></script>
<script src='debugger.js'></script>
<script>

//Treenode connects nodes with domElements
//A Treenode is not the node data it contains
//A Treenode is not the domElement that is clicked on
class TreeNode{
  constructor(node, domElement){
    this.node = node
    this.expanded = false
    let ul = document.createElement('ul')
    ul.style.border = '4px black solid'
    let li = document.createElement('li')
    if (node == null){
      debugger
    }
    let nodeType = node.type
    let nodeTypeTextNode = document.createTextNode(nodeType)
    li.appendChild(nodeTypeTextNode)
    if (node.attributes.length > 0){
      let attributeList = document.createElement('ul')
      li.appendChild(attributeList)
      for (let i = 0; i < node.attributes.length; i++){
        let attribute = document.createElement('li')
        let attributeText = node.attributes[i] + '=' + node[node.attributes[i]]

        if (Array.isArray(node[node.attributes[i]])||typeof node[node.attributes[i]] == 'object'){
          attributeText = node.attributes[i]
        }

        let attributeTextNode = document.createTextNode(attributeText)

        attribute.appendChild(attributeTextNode)
        if (Array.isArray(node[node.attributes[i]])){
          for (let j = 0; j < node[node.attributes[i]].length; j++){
              new TreeNode(node[node.attributes[i]][j], attribute)
          }
        }else if (typeof node[node.attributes[i]] == 'object'){
          new TreeNode(node[node.attributes[i]], attribute)
        }
        attributeList.appendChild(attribute)
      }
    }

    ul.appendChild(li)
    domElement.appendChild(ul)
  }
/*  
  expand(){
    //This refers to the li element that was clicked
    if (!this.treeNode.expanded){
      for (const childNode of this.treeNode.node.children) {
        new TreeNode(childNode, this)
      }
      this.treeNode.expanded = true
    }else{
      this.treeNode.expanded = false
    }
  }
*/
  attributesToString(){

  }
}

var grammar =

`
RULE_LIST = 
[
  RULE,
  SEQUENCE
  [
    RULE,
    ',',
    RULE_LIST
  ]
]

RULE = SEQUENCE[
  WS_ALLOW_BOTH[RULE_NAME],
  '=',
  WS_ALLOW_BOTH[PATTERN]
]

PATTERN_LIST = [
PATTERN,
PATTERN, ',', PATTERN_LIST
]

PATTERN = OR[
  QUOTED_STRING,
  OR,
  SEQUENCE,
  RULE_NAME,
  WS_ALLOW_BOTH
]

QUOTED_STRING= OR[
  SEQUENCE[
    SEQUENCE[S_QUOTE, STRING, S_QUOTE]
  ]
]

OR = [
  SEQUENCE[L_SQUARE_BRACKET, PATTERN_LIST, R_SQUARE_BRACKET],
  SEQUENCE['OR', L_SQUARE_BRACKET, PATTERN_LIST, R_SQUARE_BRACKET]
]

SEQUENCE = SEQUENCE[
  'SEQUENCE', L_SQUARE_BRACKET, PATTERN_LIST, R_SQUARE_BRACKET
]

STRING = OR[
SEQUENCE[STRING_CHARACTER,STRING],
STRING_CHARACTER
]

STRING_CHARACTER = OR[
  'A', 'B', 'C', 'D', 'E', 'F', 'G','H','I', 'J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
  'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
  '0','1','2','3','4','5','6','7','8','9'
]

NUMBER_STRING = OR[
  SEQUENCE[NUMBER_CHARACTER, NUMBER_STRING],
  NUMBER_CHARACTER
]

NUMBER_CHARACTER = OR[
  '0','1','2','3','4','5','6','7','8','9'
]
`

//built-ins: WS_ALLOW_BOTH
//left and right angle brackets
//COMMA
//empty
Debugger.enabled = true
Debugger.mode = 'console'

var test_parser = new Parser(grammar)
//tree = new TreeNode(test_parser.runningGrammar, document.querySelector('#test'))

let endUserCode = `
POINT_LIST=[
  POINT,
  SEQUENCE[POINT,POINT_LIST]
]

POINT=SEQUENCE[
  'POINT(',
  NUMBER,
  ',',
  NUMBER,
  ',',
  NUMBER,
  ')'
]

`
//let nodes = test_parser.parse(endUserCode)
let tree = test_parser.parse(endUserCode)
debugger
//console.log('test')

</script>
</body>
</html>
