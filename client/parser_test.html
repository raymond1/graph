<html>
<head>
<title>Test</title>
<meta charset="utf-8" /> 
<style>
.expandable{
  color: #4a8;
}
</style>
</head>
<body>
  <div id="test">

  </div>
<script src='programming.js'></script>
<script src='strings.js'></script>
<script src='parser.js'></script>
<script src='debugger.js'></script>
<script>
class ParseViewer{
  constructor(treeNode, completedOperations){
    this.rootTreeNode = treeNode
    this.viewingIndex = -1
    this.currentTreeNode = null
    this.completedOperations = completedOperations

    let button = document.createElement('button')
    button.setAttribute('type', 'button')
    let text = document.createTextNode('Highlight Next')
    button.appendChild(text)
    button.addEventListener('click', this.next.bind(this))
    treeNode.domElement.parentNode.insertBefore(button, treeNode.domElement.nextSibling)

    document.addEventListener('keydown', (event) =>{ 
      if (event.keyCode == 78){
        this.next()
      }
    })
  }
  getTreeNodeWithId(baseTreeNode = this.rootTreeNode, id){
    let treeNodeToReturn = null

    if (baseTreeNode.node.id == id){
      treeNodeToReturn = baseTreeNode
    }else{
      //is it one of the descendants?
      let children = baseTreeNode.getChildren()
      if (children.length > 0){
        for (let i = 0; i < children.length; i++){
          let treeNodeToReturn2 = this.getTreeNodeWithId(children[i], id)
          if (treeNodeToReturn2){
            treeNodeToReturn = treeNodeToReturn2
            break
          }
        }
      }
    }
    return treeNodeToReturn
  }

  next(){
    //unhighlight if necessary
    if (this.currentTreeNode){
      this.currentTreeNode.unhighlight()
    }

    this.viewingIndex = this.viewingIndex+1
    if (this.viewingIndex > this.completedOperations.length){
      this.viewingIndex = -1
    }else{
      this.currentTreeNode=this.getTreeNodeWithId(this.rootTreeNode, this.completedOperations[this.viewingIndex])
      this.currentTreeNode.highlight()
    }
  }
}
//Treenode connects nodes with domElements
//A Treenode is not the node data it contains
//A Treenode is not the domElement that is clicked on
class TreeNode{
  constructor(node, domElement){
    this.children = []
    this.node = node
    this.domElement = domElement
    this.expanded = false
    let ul = document.createElement('ul')
    ul.style.border = '4px black solid'
    ul.style.width = '100%'
    ul.style.background = '#fff'
    let li = document.createElement('li')
    li.style.width = '100%'
    li.style.background = '#fff'

    let nodeType = node.constructor.name
    let nodeTypeTextNode = document.createTextNode(nodeType)
    li.appendChild(nodeTypeTextNode)
    if (node.attributes.length > 0){
      let attributeList = document.createElement('ul')
      li.appendChild(attributeList)
      for (let i = 0; i < node.attributes.length; i++){
        let attribute = document.createElement('li')
        let attributeText = node.attributes[i] + '=' + node[node.attributes[i]]

        if (Array.isArray(node[node.attributes[i]])||typeof node[node.attributes[i]] == 'object'){
          attributeText = node.attributes[i]
        }

        let attributeTextNode = document.createTextNode(attributeText)

        attribute.appendChild(attributeTextNode)
        if (Array.isArray(node[node.attributes[i]])){
          for (let j = 0; j < node[node.attributes[i]].length; j++){
              this.children.push(new TreeNode(node[node.attributes[i]][j], attribute))
          }
        }else if (typeof node[node.attributes[i]] == 'object'){
          this.children.push(new TreeNode(node[node.attributes[i]], attribute))
        }
        attributeList.appendChild(attribute)
      }
    }

    ul.appendChild(li)
    domElement.appendChild(ul)
  }
/*  
  expand(){
    //This refers to the li element that was clicked
    if (!this.treeNode.expanded){
      for (const childNode of this.treeNode.node.children) {
        new TreeNode(childNode, this)
      }
      this.treeNode.expanded = true
    }else{
      this.treeNode.expanded = false
    }
  }
*/
  highlight(){
    this.domElement.style.background = "#ff0"
  }
  unhighlight(){
    this.domElement.style.background = "#fff"
  }
  getChildren(){
    return this.children
  }
}

var grammar =

`
RULE_LIST = 
MULTIPLE[
  RULE
]

RULE = SEQUENCE[
  WS_ALLOW_BOTH[RULE_NAME],
  '=',
  WS_ALLOW_BOTH[PATTERN]
]

PATTERN_LIST = MULTIPLE[PATTERN]

PATTERN = OR[
  QUOTED_STRING,
  OR,
  SEQUENCE,
  RULE_NAME,
  WS_ALLOW_BOTH
]

QUOTED_STRING= OR[
  SEQUENCE[
    SEQUENCE[S_QUOTE, STRING, S_QUOTE]
  ]
]

OR = [
  SEQUENCE[L_SQUARE_BRACKET, PATTERN_LIST, R_SQUARE_BRACKET],
  SEQUENCE['OR', L_SQUARE_BRACKET, PATTERN_LIST, R_SQUARE_BRACKET]
]

SEQUENCE = SEQUENCE[
  'SEQUENCE', L_SQUARE_BRACKET, PATTERN_LIST, R_SQUARE_BRACKET
]

STRING = MULTIPLE[STRING_CHARACTER]

STRING_CHARACTER = OR[
  'A', 'B', 'C', 'D', 'E', 'F', 'G','H','I', 'J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
  'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
  '0','1','2','3','4','5','6','7','8','9'
]

NUMBER_STRING = MULTIPLE[NUMBER_CHARACTER]

NUMBER_CHARACTER = OR[
  '0','1','2','3','4','5','6','7','8','9'
]

`

//built-ins: WS_ALLOW_BOTH
//left and right angle brackets
//COMMA
//empty
Debugger.enabled = true
Debugger.mode = 'console'

var test_parser = new Parser(grammar)

tree = new TreeNode(test_parser.runningGrammar, document.querySelector('#test'))
let parseViewer = new ParseViewer(tree, test_parser.matchRecorder)

let endUserCode = `
POINT_LIST=[
  POINT,
  SEQUENCE[POINT,POINT_LIST]
]

POINT=SEQUENCE[
  'POINT(',
  NUMBER,
  ',',
  NUMBER,
  ',',
  NUMBER,
  ')'
]

`

let tree2 = test_parser.parse(endUserCode)

</script>
</body>
</html>
